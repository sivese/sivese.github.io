---
layout: post
title: "Asio - The basic concepts"
date: 2024-07-12-01:20
categories: C++
tag: [ Asio, Boost, Network ]
---

## Asio

Asio 는 Boost 에 내장된 네트워크 및 비동기 입출력 라이브러리다. Boost 가 C++ 표준의 사실상 베타테스트라는 이야기가 있는데, 이는 어느정도 사실이라 볼 수 있다. Boost에 있던 것이 나중에 C++ 표준으로 들어가기도 하고, Boost 커미티 중에 표준 위원회에 참여하는 사람들이 있다. 이 때문에 Asio가 표준에 반영 될지에 대한 이야기가 꾸준히 있었는데, 이런 의견을 반영했는지 C++ 20 부터 표함 될 조짐이 보이기 시작했다.

현재 실험적으로 사용이 가능하게끔 한 상태인데, C++의 net 라이브러리의 면면을 살펴보면 Asio 와 유사한 부분들이 많다. 그래서 비록 정식 표준이 아닐지언정, Asio를 공부 할 가치는 충분히 있다고 본다. 제한적으로나마 사용이 가능하게끔 열어놓았다는 사실은 표준에 편입 할 계획이 있다는 걸 시사한다고 본다. 다만, 이것을 어느 부분까지, 그리고 어떤식으로 할 지가 명확하게 합의되지 못한 것이 아닌가 싶다.

## Install

Boost를 설치하면 Asio 라이브러리는 따라온다. 이걸 설치하는건 Linux 환경이라면 그냥 패키지 매니저를 통해 손쉽게 가능하지만, 윈도우의 경우엔 그렇지 못하다. 그냥 mingw를 사용하거나, 아니면 직접 다운받고 빌드를 하는 방법이 있다. 어찌 되었건 여기서는 다룰 생각이 없다. 구글에 검색해보면 빌드하는 법과 설치하는 법이 원체 잘 나와서 말이다.

## Basic Concepts

Asio 라이브러리에서 필수 적으로 다루는 것들이 존재하는데, 이것들을 하나하나 식 살펴보도록 하겠다. 아무래도 Asio 라이브러리를 사용하여 네트워크 프로그래밍을 하는 것이 주 목적이니 만큼, 네트워크 개념을 상세히 다룰 생각은 없다. 그렇기 때문에 네트워크에 관한 지식이 전혀 없다면 이해가 어려울 수도 있다.

### endpoint

endpoint 는 흔히 종말점이란 단어로 번역이 되는데, 네트워크에 있어 일반적으로 다루어지는 개념이다. 서버 입장에선 클라이언트가 endpoint 가 되고, 클라이언트 입장에선 서버가 endpoint 가 된다. Asio 의 endpoint 는 기본적으로 포트 및 주소 정보를 지니고 있고, 이외에 여러 유틸리티 함수가 있다.

클라이언트 입장에서는 어디에 연결할지 명확하니 endpoint 인스턴스를 먼저 생성하지만, 서버 입장에서는 어떤 클라이언트가 연결을 요청 할 지 알수없으니 먼저 연결을 수립한 후에 endpoint 인스턴스를 생성 할 수가 있다. 하지만 둘 중 어느 입장이 되었건 소켓을 생성하기 위해선 endpoint가 필요하다.

### error_code

사실 이건 Asio의 기능이라기 보다는 Boost 에서 제공하는 유틸리티다. 그냥 에러가 발생 했을 때 확인하는 용도로 사용 할 수 있다. 기본적인 사용법은 다음과 같다.

```cpp
boost::system::error_code ec;

/*
    Do something and check error
*/

auto errCode    = ec.value();
auto errMsg     = ec.message();
```

### io_service

현재 이 기능은 io_context 라는 이름으로 대체 되었다. 내가 보던 책은 io_service 였던 시절에 나왔기 때문에 이걸 고수하고 있지만, deprecated 된 내용이기 때문에 io_context 를 사용하길 권장한다. 사실 service라는 표현보다는 context가 해당 클래스의 역할을 잘 나타낸다.

일단 이 클래스는 앞서 언급한 endpoint 및 error code와 비교해보면 훨신 더 많은 기능을 가지고 있다. 기본적으로 네트워크의 io에 국한되지 않고, 일반적인 비동기 io에 대한 기능을 담당한다. 그래서 소켓 및 네트워크의 작업에 쓰이기도 하고, 타이머, 신호처리, 핸들러 등에도 쓰인다.

그래서 현재 io의 상태 및 문맥을 담당하는 기능을 하며, io와 관련하여 기능을 할 때 해당 객체를 넘겨준다.

### socket

socket이란 단어는 다들 들어봤을 것이다. 만약 들어본적이 없다면 이 포스팅을 읽기엔 너무 이르니 기초부터 하고오는 것이 좋다. 여느 네트워크 라이브러리처럼 udp, tcp로 구분하여 나뉜다. 그리고 Asio에서 socket 객체는 능동 소켓으로 스스로 연결을 요청하고 수립을 한다. 이는 요청을 기다리는 수동 소켓과는 반대되는 개념이다. 이 때문에 주로 클라이언트 입장에서 사용 된다.

### acceptor

acceptor는 서버에서 클라이언트의 요청을 받고 수락하는 역할을 한다. 그 요청을 받기전까지는 대기 상태로 존재하고, 요청을 수락한 후에 이를 처리한다. 이에 대해서는 동기/비동기적으로 진행 할 수가 있다.

### resolver

네트워크의 정보에 대한 해석을 하는 객체로, 엔드 포인트의 정보를 받아 올 때에 사용이 된다. 구버전에서는 query 객체도 따로 만들어줘야 했지만, 이제는 resolver 1개로 해결이 가능하게 바뀌었다.

## Conclusion

뭔가 두서없이 쭉 나열하고 간결하게 설명만 했는데, 사실 코드로 저것들의 예제를 하나 하나 보여주기가 심히 곤란하기 때문이다. 단독으로 사용되는 것이 아니라 클래스들이 뭉쳐서 하나의 기능을 하는 것이기 때문에 결국 위에서 언급한 것들을 하나의 코드에 다 집어넣을 수 밖에 없다. 그래서 예제 코드를 보여주며 설명하기 이전에 일단 개념을 하나하나 짚어서 다루는 것이다.